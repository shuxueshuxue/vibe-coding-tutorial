
## 1. Learn By Doing, but in LLM era
（LLM 时代，正确的的“做中学”是怎样的？）

在 [现代软件工程 习而学的软件工程教育](https://www.cnblogs.com/xinz/archive/2012/01/08/2316717.html) 中，邹欣老师提出了要进行具体能实践的，能看到结果的软件工程教育，在做中学。
按我的理解，这是通过能持续带来反馈的“做”，来倒逼“学”，给学习以动力。

这基于一个关键假设：
学 -> 做，中间满足强依赖关系。也即你不学，就没法做。
然而在当前的 LLM 时代，至少对于大部分水平不高的项目，我们发现中间的箭头弱化，
学/AI ~> 做，即若你不学，也能通过 LLM 凑合出一能用的版本。
**这时候“做”对学的倒逼作用就减少了。甚至消失。**

这并不是说 LLM 可以 cover 所有课上能布置的项目，目前的 LLM 纯靠自身依然无法产出高质量的代码，然而使用者总可以像掷骰子一样，重复地 prompt 它，在不加以引导的情况下让代码可以 work.
所以就会出现这样的情况，当程序出错时，学习者内心有两种声音，“我需要了解一下 LLM 生成的这段代码的原理，然后引导 LLM 生成更好的方案” or “我需要让它再试几次，总能成功吧”。倘若此时时间紧张，甚至明天就是 ddl，他就很可能会选择后者，用一段自己也没有掌控的代码提交了作业。

这并非只发生在课程学习中，我曾见过这样写实际业务代码的工程师。

对此，我自己找的解决方法是，有意识地放缓 vibe coding 的节奏，尤其是在架构设计阶段，确保自己完全弄清楚了整个技术栈。不停地 sanity check 自己和 AI，比较不同方案的优劣。
另外，有意识地停止写代码，去看一些高质量的博客文章（比如 hacknews 上的热门文章）和编程语言教程，确保有足够的输入。正所谓思而不学则殆，虽然现在检索东西很方便，我还是喜欢背诵记忆一些知识点，例如这套 [anki deck ](https://ido777.github.io/system-design-primer-update/en/sd_anki_flashcards.html)
